# Especificación: Sistema de Verificación QR para Recetas (Slice 06.4)

## 1. Contexto y Objetivo

### Estado Actual
- **Slice 06.3**: PDFs se generan con coordenadas personalizadas o templates
- **Problema**: No hay forma de verificar autenticidad de recetas impresas
- **Riesgo**: Falsificación de recetas médicas

### Objetivo del Slice 06.4
Añadir código QR a cada receta que permita:
1. Verificar autenticidad del documento
2. Confirmar identidad del médico emisor
3. Validar fecha de emisión
4. Proteger privacidad del paciente

## 2. Arquitectura del Sistema QR

### 2.1 Flujo de Datos

```
Generación PDF → Crear UUID único → Generar QR → Insertar en PDF
                       ↓
                 Guardar en DB
                       ↓
            Farmacia escanea QR
                       ↓
            GET /v/{uuid} (público)
                       ↓
         Mostrar datos de verificación
```

### 2.2 Contenido del QR

**URL de Verificación:**
```
https://vitalinuage.com/v/{verification_uuid}
```

**Ejemplo:**
```
https://vitalinuage.com/v/a3f5c8d2-4b7e-4a1c-9d3f-8e2b5c7a9f1d
```

### 2.3 Modelo de Datos

```python
# backend/models.py (NUEVO)
class PrescriptionVerification(Base):
    __tablename__ = "prescription_verifications"
    
    id = Column(Integer, primary_key=True, index=True)
    uuid = Column(String, unique=True, index=True, nullable=False)  # UUID v4
    consultation_id = Column(Integer, ForeignKey("clinical_consultations.id"), nullable=False)
    doctor_email = Column(String, index=True, nullable=False)
    
    # Datos públicos (visibles al escanear)
    doctor_name = Column(String, nullable=False)
    issue_date = Column(DateTime, nullable=False)
    
    # Audit
    created_at = Column(DateTime, default=datetime.utcnow)
    scanned_count = Column(Integer, default=0)  # Contador de escaneos
    last_scanned_at = Column(DateTime, nullable=True)
    
    # Relationships
    consultation = relationship("ClinicalConsultation")
```

## 3. Integración con PrescriptionMap

### 3.1 Nuevo Field Key: `qr_code`

El QR será un campo posicionable como cualquier otro:

```python
# Ejemplo de configuración en PrescriptionMap
{
    "field_key": "qr_code",
    "x_mm": 120.0,
    "y_mm": 180.0,
    "font_size_pt": 0,  # No aplica para QR
    "max_width_mm": 25.0  # Tamaño del QR: 25mm x 25mm
}
```

### 3.2 Actualización del Editor Visual

El editor `PrescriptionMapEditor.tsx` ya soporta drag-and-drop de campos. Solo necesita:
- Añadir "Código QR" a la lista de campos disponibles
- Renderizar un placeholder visual del QR en el canvas

## 4. Generación del QR

### 4.1 Librería Propuesta: `qrcode`

```python
# Instalación
pip install qrcode[pil]

# Uso básico
import qrcode
from io import BytesIO

def generate_qr_image(url: str, size_mm: float = 25.0) -> BytesIO:
    """
    Genera imagen QR en memoria.
    
    Args:
        url: URL de verificación
        size_mm: Tamaño del QR en milímetros
    
    Returns:
        BytesIO: Imagen PNG del QR
    """
    qr = qrcode.QRCode(
        version=1,  # Tamaño automático
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=10,
        border=1,
    )
    qr.add_data(url)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    
    # Convertir a bytes
    buffer = BytesIO()
    img.save(buffer, format='PNG')
    buffer.seek(0)
    
    return buffer
```

### 4.2 Integración con ReportLab

```python
# backend/services/pdf_service.py (MODIFICAR)
from reportlab.lib.utils import ImageReader

def generate_with_coordinates(cls, consultation, prescription_map, output_path):
    # ... código existente ...
    
    for field_config in prescription_map.fields_config:
        if field_config['field_key'] == 'qr_code':
            # Generar QR
            verification_uuid = create_verification_record(consultation, db)
            qr_url = f"https://vitalinuage.com/v/{verification_uuid}"
            qr_image = generate_qr_image(qr_url, field_config['max_width_mm'])
            
            # Posicionar en canvas
            x_pt = cls.mm_to_points(field_config['x_mm'])
            y_pt = height_pt - cls.mm_to_points(field_config['y_mm'])
            size_pt = cls.mm_to_points(field_config['max_width_mm'])
            
            # Dibujar imagen
            c.drawImage(
                ImageReader(qr_image),
                x_pt,
                y_pt - size_pt,  # Ajuste para alineación
                width=size_pt,
                height=size_pt,
                preserveAspectRatio=True
            )
        else:
            # ... lógica existente para campos de texto ...
```

## 5. Endpoint de Verificación Pública

### 5.1 API Endpoint (Público, sin autenticación)

```python
# backend/api/verification.py (NUEVO)
from fastapi import APIRouter, HTTPException
from sqlalchemy.orm import Session
import models
from database import get_db

router = APIRouter(
    prefix="/v",
    tags=["verificacion"]
)

@router.get("/{verification_uuid}")
async def verify_prescription(
    verification_uuid: str,
    db: Session = Depends(get_db)
):
    """
    Endpoint público de verificación de recetas.
    
    - **verification_uuid**: UUID único de la receta
    - **Sin autenticación**: Accesible para farmacias
    
    Returns:
        Datos públicos de verificación
    """
    # Buscar registro de verificación
    verification = db.query(models.PrescriptionVerification).filter(
        models.PrescriptionVerification.uuid == verification_uuid
    ).first()
    
    if not verification:
        raise HTTPException(status_code=404, detail="Receta no encontrada o inválida")
    
    # Actualizar contador de escaneos
    verification.scanned_count += 1
    verification.last_scanned_at = datetime.utcnow()
    db.commit()
    
    # Retornar datos públicos (SIN datos del paciente)
    return {
        "valid": True,
        "doctor_name": verification.doctor_name,
        "issue_date": verification.issue_date.strftime('%d/%m/%Y'),
        "verification_message": "Esta receta fue emitida por un médico verificado en Vitalinuage.",
        "scanned_count": verification.scanned_count
    }
```

### 5.2 Página de Verificación (Frontend)

```typescript
// frontend/src/pages/PublicVerification.tsx (MODIFICAR)
// Ya existe este componente, solo añadir lógica para /v/{uuid}

interface VerificationData {
    valid: boolean;
    doctor_name: string;
    issue_date: string;
    verification_message: string;
    scanned_count: number;
}

export default function PublicVerification() {
    const { uuid } = useParams();
    const [data, setData] = useState<VerificationData | null>(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        fetch(`/v/${uuid}`)
            .then(res => res.json())
            .then(setData)
            .finally(() => setLoading(false));
    }, [uuid]);
    
    if (loading) return <div>Verificando...</div>;
    
    if (!data?.valid) {
        return (
            <div className="error">
                <h2>Receta No Válida</h2>
                <p>Esta receta no pudo ser verificada.</p>
            </div>
        );
    }
    
    return (
        <div className="verification-success">
            <h2>✓ Receta Verificada</h2>
            <p><strong>Médico:</strong> {data.doctor_name}</p>
            <p><strong>Fecha de Emisión:</strong> {data.issue_date}</p>
            <p>{data.verification_message}</p>
            <small>Verificaciones: {data.scanned_count}</small>
        </div>
    );
}
```

## 6. Privacidad y Seguridad

### 6.1 Datos NO Expuestos Públicamente
- ❌ Nombre del paciente
- ❌ DNI del paciente
- ❌ Diagnóstico
- ❌ Tratamiento/Medicamentos
- ❌ Datos de contacto

### 6.2 Datos Expuestos (Solo Verificación)
- ✅ Nombre del médico
- ✅ Fecha de emisión
- ✅ Confirmación de autenticidad
- ✅ Contador de escaneos (detección de uso múltiple)

### 6.3 Protección Adicional
- **Rate Limiting**: Máximo 10 escaneos por minuto por IP
- **Logging**: Registrar IP y timestamp de cada escaneo
- **Alerta**: Notificar al médico si una receta es escaneada >5 veces

## 7. Actualización del Editor Visual

### 7.1 Añadir QR a DEFAULT_FIELDS

```typescript
// frontend/src/components/PrescriptionMapEditor.tsx
const DEFAULT_FIELDS: FieldConfig[] = [
    // ... campos existentes ...
    { 
        field_key: 'qr_code', 
        label: 'Código QR', 
        x_mm: 120, 
        y_mm: 180, 
        font_size_pt: 0,  // No aplica
        max_width_mm: 25  // 25mm x 25mm
    },
];
```

### 7.2 Renderizado Visual del QR

```typescript
// En el canvas del editor, mostrar placeholder
{field.field_key === 'qr_code' ? (
    <div 
        style={{
            width: `${(field.max_width_mm / A5_WIDTH_MM) * 100}%`,
            height: `${(field.max_width_mm / A5_HEIGHT_MM) * 100}%`,
            border: '2px dashed gray',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            fontSize: '8px',
            color: 'gray'
        }}
    >
        QR
    </div>
) : (
    <span>{field.label}</span>
)}
```

## 8. Flujo Completo E2E

```
1. Médico crea consulta → Datos guardados en DB
                              ↓
2. Click "Receta PDF" → PDFService.generate_prescription_pdf()
                              ↓
3. Detecta field_key='qr_code' → Crear PrescriptionVerification
                              ↓
4. UUID generado → https://vitalinuage.com/v/{uuid}
                              ↓
5. Generar imagen QR → Insertar en PDF con ReportLab
                              ↓
6. PDF descargado → Farmacia escanea QR
                              ↓
7. Navegador abre /v/{uuid} → Mostrar verificación
                              ↓
8. Farmacia confirma autenticidad
```

## 9. Criterios de Aceptación

### 9.1 Backend
- [ ] Modelo `PrescriptionVerification` creado
- [ ] Endpoint `GET /v/{uuid}` funcional (público)
- [ ] PDFService genera QR si `qr_code` está en fields_config
- [ ] QR apunta a URL correcta
- [ ] Datos privados NO expuestos

### 9.2 Frontend
- [ ] Editor permite posicionar campo "Código QR"
- [ ] Página `/v/{uuid}` muestra verificación
- [ ] Diseño responsive y profesional

### 9.3 Tests
- [ ] Test: Generar QR con `qrcode` library
- [ ] Test: Endpoint `/v/{uuid}` retorna datos correctos
- [ ] Test: Endpoint `/v/{uuid}` retorna 404 para UUID inválido
- [ ] Test: Contador de escaneos se incrementa

## 10. Dependencias

### 10.1 Python
```txt
# requirements.txt
qrcode[pil]==7.4.2
Pillow==10.1.0  # Requerido por qrcode
```

### 10.2 Frontend
No requiere dependencias adicionales (usa componente existente `PublicVerification.tsx`)

## 11. FILES-TO-TOUCH (Fase C)

```
backend/models.py                           # MODIFICAR: Añadir PrescriptionVerification
backend/api/verification.py                 # NUEVO: Endpoint público
backend/services/pdf_service.py             # MODIFICAR: Generar QR
backend/main.py                             # MODIFICAR: Registrar router
backend/requirements.txt                    # MODIFICAR: Añadir qrcode
frontend/src/components/PrescriptionMapEditor.tsx  # MODIFICAR: Añadir QR a DEFAULT_FIELDS
frontend/src/pages/PublicVerification.tsx   # MODIFICAR: Lógica de verificación
frontend/src/App.tsx                        # VERIFICAR: Ruta /v/:uuid existe
```

## 12. Feature Flag

```json
// config/feature-flags.json
{
    "prescription_coords_v1": true,
    "qr_verification_v1": false  // NUEVO: Inicialmente desactivado
}
```

## 13. Estimación

- **Backend (QR + Endpoint)**: 2 horas
- **Frontend (Editor + Página)**: 1 hora
- **Tests**: 1 hora
- **Total**: **4 horas**

## 14. Riesgos y Mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|--------|--------------|---------|------------|
| QR muy pequeño para escanear | Media | Alto | Tamaño mínimo 20mm x 20mm |
| URL muy larga rompe QR | Baja | Medio | UUID corto (36 chars) |
| Escaneos fraudulentos masivos | Media | Bajo | Rate limiting + alertas |
| Privacidad: datos expuestos | Baja | Crítico | Revisar endpoint cuidadosamente |

## 15. Próximos Pasos (Post-Slice 06.4)

- **Slice 06.5**: Notificaciones al médico por escaneos múltiples
- **Slice 06.6**: Dashboard de analytics de verificaciones
- **Slice 06.7**: Expiración de recetas (QR inválido después de X días)
