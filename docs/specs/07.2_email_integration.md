# Especificación: Envío de Receta por Email (Slice 07.2)

## 1. Contexto y Objetivo

### Estado Actual
- **Slice 07.1**: Sistema de envío por WhatsApp operativo
- **Infraestructura**: Endpoints públicos `/v/{uuid}/pdf` funcionando
- **Problema**: No todos los pacientes usan WhatsApp

### Objetivo del Slice 07.2
Permitir al médico enviar la receta al paciente por correo electrónico:
1. Configurar SMTP para envío de emails
2. Diseñar template HTML profesional
3. Envío asíncrono (no bloquear UI del médico)
4. Botón "Email" en historial de consultas

## 2. Arquitectura del Sistema

### 2.1 Flujo de Datos

```
Médico click "Enviar Email" → Crear/Obtener UUID verificación
                                        ↓
                              Validar email del paciente
                                        ↓
                        BackgroundTasks.add_task(send_email)
                                        ↓
                              Respuesta inmediata 202
                                        ↓
                    (Background) Renderizar template HTML
                                        ↓
                    (Background) Enviar vía SMTP
                                        ↓
                    (Background) Log resultado
```

## 3. Configuración Email (Resend)

### 3.1 Variables de Entorno

```bash
# .env (backend)
RESEND_API_KEY=re_123456789
EMAIL_FROM_ADDRESS=noreply@vitalinuage.com
EMAIL_FROM_NAME=Vitalinuage
```

### 3.2 Librería

Usaremos el SDK oficial de Resend para Python:
`pip install resend`

## 4. Template de Email

### 4.1 Diseño HTML
(Se mantiene el mismo diseño HTML con Jinja2)

...

## 5. Backend Service

### 5.1 EmailService

```python
# backend/services/email_service.py

import resend
from jinja2 import Template
import os

class EmailService:
    """
    Servicio de envío de emails usando Resend.
    """
    
    @staticmethod
    def send_prescription_email(
        to_email: str,
        patient_name: str,
        doctor_name: str,
        pdf_url: str,
        issue_date: str
    ) -> bool:
        try:
            resend.api_key = os.getenv('RESEND_API_KEY')
            
            # Renderizar template (igual que antes)
            # ...
            
            params = {
                "from": f"{os.getenv('EMAIL_FROM_NAME', 'Vitalinuage')} <{os.getenv('EMAIL_FROM_ADDRESS')}>",
                "to": [to_email],
                "subject": f"Receta Médica - {doctor_name}",
                "html": html_content,
            }

            email = resend.Emails.send(params)
            return True
            
        except Exception as e:
            print(f"Error sending email: {e}")
            return False
```

## 6. Endpoint de API

### 6.1 Endpoint Asíncrono

```python
# backend/api/consultations.py (añadir al verification_router)

from fastapi import BackgroundTasks

@verification_router.post("/{consultation_id}/send-email")
async def send_prescription_email(
    consultation_id: int,
    background_tasks: BackgroundTasks,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    """
    Envía receta por email (asíncrono).
    
    - **consultation_id**: ID de la consulta
    - **Requiere autenticación**: Solo el médico dueño
    
    Returns:
        {"status": "queued", "message": "..."}
    """
    import datetime
    from services.email_service import EmailService
    
    # 1. Verificar autorización
    consultation = db.query(models.ClinicalConsultation).filter(
        models.ClinicalConsultation.id == consultation_id,
        models.ClinicalConsultation.owner_id == current_user.email
    ).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Consultation not found")
    
    # 2. Validar email del paciente
    if not consultation.patient.email:
        raise HTTPException(
            status_code=400, 
            detail="Patient does not have an email address"
        )
    
    # 3. Obtener o crear verificación
    verification = db.query(models.PrescriptionVerification).filter(
        models.PrescriptionVerification.consultation_id == consultation_id
    ).first()
    
    if not verification:
        import uuid as uuid_lib
        verification = models.PrescriptionVerification(
            uuid=str(uuid_lib.uuid4()),
            consultation_id=consultation_id,
            doctor_email=current_user.email,
            doctor_name=current_user.professional_name or "Dr. Vitalinuage",
            issue_date=datetime.datetime.utcnow()
        )
        db.add(verification)
        db.commit()
        db.refresh(verification)
    
    # 4. Construir datos
    patient_name = f"{consultation.patient.nombre} {consultation.patient.apellido_paterno}"
    doctor_name = current_user.professional_name or "Dr. Vitalinuage"
    pdf_url = f"{os.getenv('BASE_URL', 'http://localhost:8000')}/v/{verification.uuid}/pdf"
    issue_date = verification.issue_date.strftime('%d/%m/%Y')
    
    # 5. Añadir tarea en background
    background_tasks.add_task(
        EmailService.send_prescription_email,
        to_email=consultation.patient.email,
        patient_name=patient_name,
        doctor_name=doctor_name,
        pdf_url=pdf_url,
        issue_date=issue_date
    )
    
    # 6. Respuesta inmediata
    return {
        "status": "queued",
        "message": f"Email queued for delivery to {consultation.patient.email}"
    }
```

## 7. Integración Frontend

### 7.1 Botón en ConsultationManager

```typescript
// frontend/src/components/ConsultationManager.tsx

import { Mail } from 'lucide-react';

const handleSendEmail = async (consultation: ClinicalConsultation) => {
    try {
        const token = localStorage.getItem('token');
        const apiUrl = import.meta.env.VITE_API_URL || 'http://localhost:8000';

        // Validar email
        if (!consultation.patient?.email) {
            toast.error('El paciente no tiene email registrado');
            return;
        }

        // Enviar email
        const response = await fetch(
            `${apiUrl}/api/consultas/${consultation.id}/send-email`,
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            }
        );

        if (response.ok) {
            const data = await response.json();
            toast.success(`Email enviado a ${consultation.patient.email}`);
        } else {
            const error = await response.json();
            toast.error(error.detail || 'Error al enviar email');
        }
    } catch (err) {
        console.error('Error sending email:', err);
        toast.error('Error al enviar email');
    }
};

// Botón UI
<button
    onClick={() => handleSendEmail(c)}
    className="flex items-center gap-1 px-3 py-1.5 bg-blue-50 text-blue-600 rounded-lg hover:bg-blue-100 transition-colors text-xs font-medium shadow-sm"
    title="Enviar por Email"
>
    <Mail className="w-3.5 h-3.5" />
    Email
</button>
```

## 8. Criterios de Aceptación

### 8.1 Backend
- [ ] EmailService configurado con SMTP
- [ ] Template HTML renderiza correctamente
- [ ] Endpoint `/api/consultas/{id}/send-email` funcional
- [ ] Envío asíncrono con BackgroundTasks
- [ ] Validación de email del paciente
- [ ] Logging de envíos exitosos/fallidos

### 8.2 Frontend
- [ ] Botón "Email" visible en cada consulta
- [ ] Toast de confirmación al enviar
- [ ] Toast de error si paciente no tiene email
- [ ] Validación antes de enviar

### 8.3 Email
- [ ] Template HTML responsive
- [ ] Botón de descarga funcional
- [ ] Información del médico visible
- [ ] Disclaimer de privacidad incluido

## 9. FILES-TO-TOUCH (Fase C)

```
backend/services/email_service.py                    # NUEVO: Servicio SMTP
backend/services/email_templates/prescription_email.html  # NUEVO: Template HTML
backend/api/consultations.py                         # MODIFICAR: Añadir endpoint send-email
frontend/src/components/ConsultationManager.tsx      # MODIFICAR: Botón Email
frontend/src/contracts/consultations.ts              # MODIFICAR: Añadir email a patient
```

## 10. Dependencias

### 10.1 Backend
```txt
# requirements.txt (ya incluido en Python estándar)
# smtplib - Built-in
# email - Built-in
# jinja2 - Ya instalado
```

### 10.2 Variables de Entorno
```bash
# .env
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=noreply@vitalinuage.com
SMTP_PASSWORD=your_app_password_here
SMTP_FROM_NAME=Vitalinuage
SMTP_FROM_EMAIL=noreply@vitalinuage.com
SMTP_USE_TLS=true
BASE_URL=https://vitalinuage.com
```

## 11. Feature Flag

```json
// config/feature-flags.json
{
    "prescription_coords_v1": true,
    "qr_verification_v1": true,
    "whatsapp_sharing_v1": true,
    "email_delivery_v1": false  // NUEVO: Inicialmente desactivado
}
```

## 12. Estimación

- **Backend (EmailService + Endpoint)**: 2 horas
- **Template HTML**: 1 hora
- **Frontend (Botón + Lógica)**: 1 hora
- **Tests**: 1 hora
- **Total**: **5 horas**

## 13. Riesgos y Mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|--------|--------------|---------|------------|
| Credenciales SMTP incorrectas | Media | Alto | Validar en startup, logs claros |
| Email del paciente inválido | Alta | Bajo | Validación antes de enviar |
| Email marcado como spam | Media | Medio | Usar dominio verificado, SPF/DKIM |
| Timeout en envío SMTP | Baja | Medio | BackgroundTasks evita bloqueo |

## 14. Seguridad

### 14.1 Consideraciones
- ✅ **Credenciales SMTP**: Almacenar en variables de entorno
- ✅ **Validación de email**: Verificar formato antes de enviar
- ✅ **Rate limiting**: Máximo 10 emails por minuto por médico
- ✅ **Logging**: Registrar todos los envíos (éxito/fallo)

### 14.2 Privacidad
- ✅ **Contenido del email**: No incluir diagnóstico ni tratamiento
- ✅ **Link público**: Mismo UUID que WhatsApp (ya seguro)
- ✅ **Disclaimer**: Incluir aviso de confidencialidad

## 15. Próximos Pasos (Post-Slice 07.2)

- **Slice 07.3**: Historial de envíos (email + WhatsApp)
- **Slice 07.4**: Confirmación de lectura (email tracking)
- **Slice 07.5**: Reenvío de recetas
