# Especificación: Generación de PDF con Mapas de Coordenadas (Slice 06.3)

## 1. Contexto y Objetivo

### Estado Actual
- **Slice 06.1**: Backend API `/api/maps` persiste configuraciones de coordenadas
- **Slice 06.2**: Editor visual permite a médicos configurar posiciones de campos
- **Infraestructura Existente**: `pdf_templates.py` con templates HTML/CSS para WeasyPrint

### Objetivo del Slice 06.3
Crear un servicio de generación de PDFs que:
1. Consuma los datos de `PrescriptionMap` (coordenadas en mm)
2. Posicione campos de texto en ubicaciones exactas usando ReportLab
3. Genere PDFs descargables desde consultas clínicas

## 2. Decisión Técnica: ReportLab vs WeasyPrint

### Análisis Comparativo

| Criterio | ReportLab | WeasyPrint (Actual) |
|----------|-----------|---------------------|
| **Posicionamiento Absoluto** | ✅ Nativo (canvas.drawString(x, y)) | ⚠️ CSS absolute (menos preciso) |
| **Coordenadas mm → pt** | ✅ Directo (1mm = 2.83465pt) | ⚠️ Conversión CSS compleja |
| **Background Image** | ✅ canvas.drawImage() | ✅ CSS background-image |
| **Curva de Aprendizaje** | ⚠️ API de bajo nivel | ✅ HTML/CSS familiar |
| **Mantenibilidad** | ⚠️ Código Python verboso | ✅ Templates HTML reutilizables |

### Decisión: **Arquitectura Híbrida**

```
┌─────────────────────────────────────────┐
│  ¿Médico tiene PrescriptionMap activo?  │
└──────────────┬──────────────────────────┘
               │
       ┌───────┴───────┐
       │               │
      SÍ              NO
       │               │
       ▼               ▼
┌──────────────┐  ┌──────────────┐
│  ReportLab   │  │  WeasyPrint  │
│  (Coordenadas│  │  (Templates  │
│   exactas)   │  │   HTML/CSS)  │
└──────────────┘  └──────────────┘
```

**Justificación:**
- **ReportLab**: Solo cuando el médico configuró coordenadas personalizadas
- **WeasyPrint**: Fallback para médicos sin configuración (usa templates existentes)
- **Beneficio**: Máxima precisión donde se necesita, simplicidad donde no

## 3. Arquitectura del Servicio

### 3.1 Estructura de Archivos
```
backend/
├── services/
│   └── pdf_service.py          # NUEVO: Lógica de generación
├── api/
│   └── print.py                # NUEVO: Endpoints de impresión
├── pdf_templates.py            # EXISTENTE: Templates WeasyPrint
└── models.py                   # EXISTENTE: PrescriptionMap model
```

### 3.2 Clase PDFService (Pseudocódigo)

```python
# backend/services/pdf_service.py
from reportlab.pdfgen import canvas
from reportlab.lib.units import mm
from reportlab.lib.pagesizes import A5
from weasyprint import HTML
from sqlalchemy.orm import Session
import models

class PDFService:
    """
    Servicio de generación de PDFs con soporte para coordenadas personalizadas.
    """
    
    @staticmethod
    def mm_to_points(millimeters: float) -> float:
        """
        Convierte milímetros a puntos PDF.
        1mm = 2.83465 points (estándar PDF)
        """
        return millimeters * 2.83465
    
    @staticmethod
    def get_active_map(doctor_email: str, db: Session) -> Optional[models.PrescriptionMap]:
        """
        Obtiene el mapa de coordenadas activo del médico.
        
        Returns:
            PrescriptionMap si existe y está activo, None en caso contrario
        """
        return db.query(models.PrescriptionMap).filter(
            models.PrescriptionMap.doctor_id == doctor_email,
            models.PrescriptionMap.is_active == True
        ).first()
    
    @staticmethod
    def extract_field_value(consultation: models.ClinicalConsultation, field_key: str) -> str:
        """
        Mapea field_key a datos reales de la consulta.
        
        Mapping:
            - patient_name → "{consultation.patient.nombre} {consultation.patient.apellido_paterno}"
            - patient_dni → consultation.patient.dni
            - date → consultation.fecha_consulta.strftime('%d/%m/%Y')
            - diagnosis → consultation.diagnostico
            - treatment → consultation.tratamiento
            - doctor_signature → "Firma y Sello Médico"
        """
        FIELD_MAPPING = {
            'patient_name': lambda c: f"{c.patient.nombre} {c.patient.apellido_paterno}",
            'patient_dni': lambda c: c.patient.dni or "N/A",
            'date': lambda c: c.fecha_consulta.strftime('%d/%m/%Y') if c.fecha_consulta else "",
            'diagnosis': lambda c: c.diagnostico or "",
            'treatment': lambda c: c.tratamiento or "",
            'doctor_signature': lambda c: "Firma y Sello Médico"
        }
        
        mapper = FIELD_MAPPING.get(field_key)
        return mapper(consultation) if mapper else ""
    
    @classmethod
    def generate_with_coordinates(
        cls,
        consultation: models.ClinicalConsultation,
        prescription_map: models.PrescriptionMap,
        output_path: str
    ) -> bytes:
        """
        Genera PDF usando ReportLab con coordenadas exactas.
        
        Args:
            consultation: Datos de la consulta clínica
            prescription_map: Configuración de coordenadas
            output_path: Ruta temporal para el PDF
        
        Returns:
            bytes: Contenido del PDF generado
        """
        # 1. Crear canvas con dimensiones del mapa
        width_pt = cls.mm_to_points(prescription_map.canvas_width_mm)
        height_pt = cls.mm_to_points(prescription_map.canvas_height_mm)
        
        c = canvas.Canvas(output_path, pagesize=(width_pt, height_pt))
        
        # 2. Si hay imagen de fondo, renderizarla primero
        if prescription_map.background_image_url:
            # TODO: Descargar imagen y dibujarla
            # c.drawImage(background_image_path, 0, 0, width=width_pt, height=height_pt)
            pass
        
        # 3. Iterar sobre fields_config y posicionar cada campo
        for field_config in prescription_map.fields_config:
            # Extraer valor del campo
            field_value = cls.extract_field_value(consultation, field_config['field_key'])
            
            # Convertir coordenadas mm → puntos
            x_pt = cls.mm_to_points(field_config['x_mm'])
            # IMPORTANTE: ReportLab usa origen en esquina inferior izquierda
            # Invertir Y: y_pdf = height - y_mm
            y_pt = height_pt - cls.mm_to_points(field_config['y_mm'])
            
            # Configurar fuente
            font_size = field_config.get('font_size_pt', 10)
            c.setFont("Helvetica", font_size)
            
            # Dibujar texto
            c.drawString(x_pt, y_pt, field_value)
        
        # 4. Finalizar y guardar
        c.save()
        
        # 5. Leer bytes del archivo
        with open(output_path, 'rb') as f:
            return f.read()
    
    @classmethod
    def generate_with_template(
        cls,
        consultation: models.ClinicalConsultation,
        template_id: str = "modern"
    ) -> bytes:
        """
        Genera PDF usando WeasyPrint con templates HTML/CSS.
        Fallback para médicos sin mapa configurado.
        
        Args:
            consultation: Datos de la consulta clínica
            template_id: ID del template ('minimal', 'modern', 'classic')
        
        Returns:
            bytes: Contenido del PDF generado
        """
        from pdf_templates import MINIMAL_TEMPLATE, MODERN_TEMPLATE, CLASSIC_TEMPLATE
        from jinja2 import Template
        
        # 1. Seleccionar template
        templates = {
            'minimal': MINIMAL_TEMPLATE,
            'modern': MODERN_TEMPLATE,
            'classic': CLASSIC_TEMPLATE
        }
        template_html = templates.get(template_id, MODERN_TEMPLATE)
        
        # 2. Preparar datos para el template
        context = {
            'patient_name': f"{consultation.patient.nombre} {consultation.patient.apellido_paterno}",
            'patient_dni': consultation.patient.dni,
            'date': consultation.fecha_consulta.strftime('%d/%m/%Y'),
            'diagnosis': consultation.diagnostico,
            'treatment': consultation.tratamiento,
            'doctor_name': consultation.doctor.professional_name or consultation.doctor.email,
            'doctor_specialty': consultation.doctor.specialty or "Medicina General",
            'doctor_registration': consultation.doctor.registration_number or "N/A"
        }
        
        # 3. Renderizar template
        template = Template(template_html)
        html_content = template.render(**context)
        
        # 4. Generar PDF con WeasyPrint
        pdf_bytes = HTML(string=html_content).write_pdf()
        
        return pdf_bytes
    
    @classmethod
    def generate_prescription_pdf(
        cls,
        consultation: models.ClinicalConsultation,
        doctor_email: str,
        db: Session
    ) -> bytes:
        """
        Método principal: decide qué estrategia usar (coordenadas vs template).
        
        Args:
            consultation: Datos de la consulta clínica
            doctor_email: Email del médico autenticado
            db: Sesión de base de datos
        
        Returns:
            bytes: Contenido del PDF generado
        """
        import tempfile
        
        # 1. Buscar mapa activo del médico
        prescription_map = cls.get_active_map(doctor_email, db)
        
        # 2. Decidir estrategia
        if prescription_map:
            # Usar coordenadas personalizadas (ReportLab)
            with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as tmp:
                pdf_bytes = cls.generate_with_coordinates(
                    consultation, 
                    prescription_map, 
                    tmp.name
                )
            return pdf_bytes
        else:
            # Usar template estándar (WeasyPrint)
            return cls.generate_with_template(consultation, template_id="modern")
```

## 4. Endpoint de API

### 4.1 Especificación del Endpoint

```python
# backend/api/print.py
from fastapi import APIRouter, Depends, HTTPException
from fastapi.responses import Response
from sqlalchemy.orm import Session
import models
from database import get_db
from dependencies import get_current_user
from services.pdf_service import PDFService

router = APIRouter(
    prefix="/api/consultas",
    tags=["impresion"]
)

@router.get("/{consultation_id}/pdf")
async def generate_prescription_pdf(
    consultation_id: int,
    db: Session = Depends(get_db),
    current_user: models.User = Depends(get_current_user)
):
    """
    Genera PDF de receta médica para una consulta.
    
    - **consultation_id**: ID de la consulta clínica
    - **Autenticación**: Requiere JWT token
    - **Autorización**: Solo el médico dueño de la consulta puede generar el PDF
    
    Returns:
        PDF file (application/pdf)
    
    Raises:
        404: Consulta no encontrada
        403: Usuario no autorizado
    """
    # 1. Obtener consulta
    consultation = db.query(models.ClinicalConsultation).filter(
        models.ClinicalConsultation.id == consultation_id
    ).first()
    
    if not consultation:
        raise HTTPException(status_code=404, detail="Consultation not found")
    
    # 2. Verificar autorización
    if consultation.doctor_id != current_user.email:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # 3. Generar PDF
    pdf_bytes = PDFService.generate_prescription_pdf(
        consultation=consultation,
        doctor_email=current_user.email,
        db=db
    )
    
    # 4. Retornar PDF
    return Response(
        content=pdf_bytes,
        media_type="application/pdf",
        headers={
            "Content-Disposition": f"inline; filename=receta_{consultation_id}.pdf"
        }
    )
```

### 4.2 Registro del Router

```python
# backend/main.py
from api import print as print_api

app.include_router(print_api.router)
```

## 5. Conversión de Coordenadas

### 5.1 Sistema de Coordenadas

```
Editor Visual (Frontend)          ReportLab (Backend)
┌─────────────────────┐           ┌─────────────────────┐
│ (0,0)               │           │                     │
│   ┌─────────────┐   │           │                     │
│   │   Canvas    │   │           │                     │
│   │   A5        │   │           │   Canvas A5         │
│   │             │   │           │                     │
│   │             │   │           │                     │
│   └─────────────┘   │           │                     │
│            (148,210)│           │              (0,0)  │
└─────────────────────┘           └─────────────────────┘
Origen: Top-Left                  Origen: Bottom-Left
Unidades: mm                      Unidades: points (pt)
```

### 5.2 Fórmulas de Conversión

```python
# mm → points
x_pt = x_mm * 2.83465
y_pt = y_mm * 2.83465

# Inversión de eje Y (Top-Left → Bottom-Left)
y_pdf = canvas_height_pt - y_pt

# Ejemplo:
# Campo en (20mm, 40mm) en canvas de 210mm altura
# → x_pdf = 20 * 2.83465 = 56.69 pt
# → y_pdf = (210 * 2.83465) - (40 * 2.83465) = 595.28 - 113.39 = 481.89 pt
```

## 6. Feature Flag

### 6.1 Configuración
```json
// config/feature-flags.json
{
  "prescription_coords_v1": true  // Ya habilitado en Slice 06.1
}
```

### 6.2 Verificación en PDFService
```python
def check_feature_enabled() -> bool:
    import json
    with open('config/feature-flags.json') as f:
        flags = json.load(f)
    return flags.get('prescription_coords_v1', False)

# Usar en generate_prescription_pdf():
if not check_feature_enabled():
    # Siempre usar template, ignorar mapas
    return cls.generate_with_template(consultation)
```

## 7. Dependencias

### 7.1 Nuevas Dependencias Python
```txt
# requirements.txt
reportlab==4.0.7        # Generación PDF con coordenadas
Pillow==10.1.0          # Procesamiento de imágenes de fondo
```

### 7.2 Dependencias Existentes (Mantener)
```txt
weasyprint==60.1        # Templates HTML/CSS (fallback)
jinja2==3.1.2           # Renderizado de templates
```

## 8. Criterios de Aceptación

### 8.1 Tests de Integración

#### Test 1: PDF con Coordenadas Personalizadas
```python
def test_generate_pdf_with_custom_map(db_session, test_consultation):
    # 1. Crear mapa personalizado
    pmap = models.PrescriptionMap(
        doctor_id="test@doctor.com",
        name="Test Map",
        canvas_width_mm=148,
        canvas_height_mm=210,
        fields_config=[
            {
                "field_key": "patient_name",
                "x_mm": 20,
                "y_mm": 40,
                "font_size_pt": 12,
                "max_width_mm": 80
            }
        ],
        is_active=True
    )
    db_session.add(pmap)
    db_session.commit()
    
    # 2. Generar PDF
    pdf_bytes = PDFService.generate_prescription_pdf(
        consultation=test_consultation,
        doctor_email="test@doctor.com",
        db=db_session
    )
    
    # 3. Verificar
    assert pdf_bytes is not None
    assert len(pdf_bytes) > 0
    assert pdf_bytes[:4] == b'%PDF'  # PDF magic number
```

#### Test 2: Fallback a Template
```python
def test_generate_pdf_without_map(db_session, test_consultation):
    # No crear mapa → debe usar template
    pdf_bytes = PDFService.generate_prescription_pdf(
        consultation=test_consultation,
        doctor_email="test@doctor.com",
        db=db_session
    )
    
    assert pdf_bytes is not None
    assert pdf_bytes[:4] == b'%PDF'
```

#### Test 3: Endpoint de API
```python
def test_pdf_endpoint_auth(client, test_consultation):
    token = create_test_token("test@doctor.com")
    
    response = client.get(
        f"/api/consultas/{test_consultation.id}/pdf",
        headers={"Authorization": f"Bearer {token}"}
    )
    
    assert response.status_code == 200
    assert response.headers['content-type'] == 'application/pdf'
```

### 8.2 Smoke E2E
1. Médico configura mapa en `/settings/talonario`
2. Guarda con coordenadas específicas
3. Va a perfil de paciente
4. Abre consulta existente
5. Click en "Descargar Receta" (botón nuevo)
6. PDF descargado muestra campos en posiciones exactas

## 9. FILES-TO-TOUCH (Fase C)

```
backend/services/pdf_service.py          # NUEVO
backend/api/print.py                     # NUEVO
backend/main.py                          # MODIFICAR: registrar router
backend/requirements.txt                 # MODIFICAR: añadir reportlab
backend/tests/test_pdf_service.py        # NUEVO
```

## 10. Estimación

- **Implementación PDFService**: 2 horas
- **Endpoint API**: 30 minutos
- **Tests de Integración**: 1 hora
- **Verificación E2E**: 30 minutos
- **Total**: **4 horas**

## 11. Riesgos y Mitigaciones

| Riesgo | Probabilidad | Impacto | Mitigación |
|--------|--------------|---------|------------|
| ReportLab no soporta fuentes personalizadas | Media | Alto | Usar fuentes estándar (Helvetica, Times) |
| Coordenadas Y invertidas causan confusión | Alta | Medio | Documentar claramente + tests |
| Background image no se renderiza | Media | Bajo | Fase 2: implementar después de validar texto |
| Performance lento con muchos campos | Baja | Medio | Cachear PDFs generados (futuro) |

## 12. Próximos Pasos (Post-Slice 06.3)

- **Slice 06.4**: Soporte para imágenes de fondo en PDFs
- **Slice 06.5**: Caché de PDFs generados
- **Slice 06.6**: Exportación masiva de recetas
